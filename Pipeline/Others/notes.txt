a pc permission checker
    -> checks a one period exception signal, if it's on then allow possible exception addr sets
    -> checks a one period reset signal, if it's on then allow entrance into the reset region

a mem permission checker/decoder
    -> alligns addresses if valid
    -> if reg write_m is on, and the alu_out_m is outside the bounds of the stack region, and rd_m == sp, then exception_invalid store
    -> if reg write_m is on

address mapping and signals testing code:

0x0000_0000: lui x5,0x0004_0; 
0x0000_0004: lw x6,0(x0)
0x0000_0008: jalr x1, 0(x5);


0x0004_0000: lui x5, 0x00080; 
0x0004_0004: lui x6,0x00140
0x0004_0008: lw x6,0(x6)
0x0004_000c: jalr x1,0(x5); 


0x0008_0000: lui x5,0x0010;
0x0008_0004: lui x6,0x00180
0x0008_0008: lw x6,0(x6)
0x0008_000c: jalr x1,0(x5); 

0x000a_0000: addi x0,x0,0;
0x000a_0004: addi x0,x0,0;
0x000a_0008: addi x0,x0,0;



wire pc state = bit logic calculation 

if an exception is detected in FETCH -> 
load exception code[4:0] in if_id
if(exception code[4] = 0 && 3:0 !=111)
{
    flush if_id,
}
-> in datapath, w_pc_trap_f = !exception code[4] && 3:0!=111
    then assign pc_in =trap begin addr

if an exception is detected in EX ->
load exception code[4:0] in ex_mem
if(exception code[4] = 1 && 3:0!=111)
{
    flush if_id, flush id_ex, flush ex_mem
}
-> in datapath, w_pc_trap_e = exception code[4] && 3:0!=111
    then assign pc_in =trap begin addr


TODO
-> see what is modified by hardware when switching into and out of the trap vector
        -> IN: mepc <= current pc
               mie  <= 32'b0;
               mcause <= exception code // bit 31 = 1 for interrupt, 0 for exception
               mtval <= relevant exception data


        -> OUT: mie <= default mie cst
                pc <= mepc
                ** if machine mode is entered and immediately left after an IF detected exception, a bubble needs to be inserted in order to delay the imm into ID


    // on detecting an exception in f or in e, a prioritary csr write signal is emitted in order
    // to write relevant data in the csr reg file

    // if the exception is generated in f, then the data will be written in d,
    // if the exception is generated in ex, then the data will be written in mem         

-> list of csr instructions
-> list of exception codes and solving solutions
-> ecall functionality

** global initialized data must go into rom (the sidata = start of initial data).
    -> in the reset vector the initialized data must be copied into ram into sdata

Exceptions:
1. E_FETCH_ADDR_MISALIGNED 4'b0000 ->0
    -> mtval = pc_addr
    -> solution -> terminate program

2. E_ILLEGAL_INSTR 4'b0010 ->2
    -> mtval = faulty instr
    -> solution -> terminate

3. E_SP_OUT_OF_RANGE 4'b0011 ->3
    -> mtval = faulty sp generated in ex
    -> solution -> terminate program
    
4. E_LOAD_ADDR_MISALIGNED 4'b0100 ->4
    -> mtval = faulty addr
    -> solution -> terminate program

5. E_LOAD_ACCESS_FAULT 4'b0101 ->5
    -> mtval = faulty addr
    -> solution -> terminate

6. E_STORE_ADDR_MISALIGNED 4'b0110 ->6
    -> mtval = faulty addr
    -> solution -> terminate

7. E_STORE_ADDR_FAULT 4'b0111 ->7
    -> mtval = faulty addr
    -> solution -> terminate

8. E_ECALL 4'b1000 ->8
    -> mtval = 0
    -> solution: query the a7 register -> 0 = exit with the code in a0
                                       -> 1 = uart print char with the char in a0 (lsb)
    -> mret -> mepc+=4
                    



todo:   -> write physical memory protection unit with pmpcfg registers that hold the memory region limits
            -> these are initialized in the reset vector
        
        -> write the trap vector assembly (with special csr instructions)






trap vector:

    csrrw t0,mscratch,t0
    addi t0,t0,-16
    sw t1, 0(t0)
    sw t2, 4(t0)
    sw a7, 8(t0)
    sw a0, 12(t0)

    csrrw t1,mcause,t1 // in t1 i hold exception cause
    addi t2,x0,0 

    beq t1,t2, fetch_addr_mis -> 0
    addi t2,t2,2
    beq t1,t2, illegal_instr -> 2
    addi t2,t2,1
    beq t1,t2, sp_out_of_range -> 3
    addi t2,t2,1
    beq t1,t2, load_addr_mis -> 4
    addi t2,t2,1
    beq t1,t2, load_access_fault -> 5
    addi t2,t2,1
    beq t1,t2, store_addr_mis -> 6
    addi t2,t2,1
    beq t1,t2, store_addr_fault -> 7
    addi t2,t2,1
    beq t1,t2, ecall -> 8

done:

    lw t1, 0(t0)
    lw t2, 4(t0)
    lw a7, 8(t0)
    lw a0, 12(t0)
    addi t0,t0,16
    csrrw t0,mscratch,t0
    mret

exit:
    jal x0, exit

fetch_addr_mis:
    jal x0,exit

illegal_instr:
    jal x0,exit

sp_out_of_range:
    jal x0,exit

load_addr_mis:
    jal x0,exit

load_access_fault:
    jal x0,exit

store_addr_mis:
    jal x0,exit

store_addr_fault:
    jal x0,exit

ecall:
    csrrw t2,mepc,t2
    addi t2,t2,4
    csrrw t2,mepc,t2

    addi t2,x0,0
    beq a7,t2, exit
    addi t2,t2,1
    beq a7,t2, uart

ecall_end:

    jal x0,done

uart:
    # in a0 i have the print data
    

    beq t2,t2,ecall_end




