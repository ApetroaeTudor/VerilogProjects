a pc permission checker
    -> checks a one period exception signal, if it's on then allow possible exception addr sets
    -> checks a one period reset signal, if it's on then allow entrance into the reset region

a mem permission checker/decoder
    -> alligns addresses if valid
    -> if reg write_m is on, and the alu_out_m is outside the bounds of the stack region, and rd_m == sp, then exception_invalid store
    -> if reg write_m is on

address mapping and signals testing code:

0x0000_0000: lui x5,0x0004_0; 
0x0000_0004: lw x6,0(x0)
0x0000_0008: jalr x1, 0(x5);


0x0004_0000: lui x5, 0x00080; 
0x0004_0004: lui x6,0x00140
0x0004_0008: lw x6,0(x6)
0x0004_000c: jalr x1,0(x5); 


0x0008_0000: lui x5,0x0010;
0x0008_0004: lui x6,0x00180
0x0008_0008: lw x6,0(x6)
0x0008_000c: jalr x1,0(x5); 

0x000a_0000: addi x0,x0,0;
0x000a_0004: addi x0,x0,0;
0x000a_0008: addi x0,x0,0;



wire pc state = bit logic calculation 

if an exception is detected in FETCH -> 
load exception code[4:0] in if_id
if(exception code[4] = 0 && 3:0 !=111)
{
    flush if_id,
}
-> in datapath, w_pc_trap_f = !exception code[4] && 3:0!=111
    then assign pc_in =trap begin addr

if an exception is detected in EX ->
load exception code[4:0] in ex_mem
if(exception code[4] = 1 && 3:0!=111)
{
    flush if_id, flush id_ex, flush ex_mem
}
-> in datapath, w_pc_trap_e = exception code[4] && 3:0!=111
    then assign pc_in =trap begin addr



-> see what is modified by hardware when switching into and out of the trap vector
        -> IN: mepc <= current pc
               mie  <= 32'b0;
               mcause <= exception code // bit 31 = 1 for interrupt, 0 for exception
               mtval <= relevant exception data


        -> OUT: mie <= default mie cst
                pc <= mepc
                ** if machine mode is entered and immediately left after an IF detected exception, a bubble needs to be inserted in order to delay the imm into ID


    // on detecting an exception in f or in e, a prioritary csr write signal is emitted in order

     // if the exception is generated in f, then the data will be written in d,
    // if the exception is generated in ex, then the data will be written in mem         


-> list of csr instructions
-> list of exception codes and solving solutions
-> ecall functionality

** global initialized data must go into rom (the sidata = start of initial data).
    -> in the reset vector the initialized data must be copied into ram into sdata


Exceptions:
1. E_FETCH_ADDR_MISALIGNED 4'b0000 ->0
    -> mtval = pc_addr
    -> solution -> terminate program

2. E_ILLEGAL_INSTR 4'b0010 ->2
    -> mtval = faulty instr
    -> solution -> terminate

3. E_SP_OUT_OF_RANGE 4'b0011 ->3
    -> mtval = faulty sp generated in ex
    -> solution -> terminate program
    
4. E_LOAD_ADDR_MISALIGNED 4'b0100 ->4
    -> mtval = faulty addr
    -> solution -> terminate program

5. E_LOAD_ACCESS_FAULT 4'b0101 ->5
    -> mtval = faulty addr
    -> solution -> terminate

6. E_STORE_ADDR_MISALIGNED 4'b0110 ->6
    -> mtval = faulty addr
    -> solution -> terminate

7. E_STORE_ADDR_FAULT 4'b0111 ->7
    -> mtval = faulty addr
    -> solution -> terminate

8. E_ECALL 4'b1000 ->8
    -> mtval = 0
    -> solution: query the a7 register -> 0 = exit with the code in a0
                                       -> 1 = uart print char with the char in a0 (lsb)
    -> mret -> mepc+=4
                    



todo: -> instructions to add: blt, bge, auipc
      -> write physical memory protection unit with pmpcfg registers that hold the memory region limits
            -> these are initialized in the reset vector
        
        -> write the trap vector assembly (with special csr instructions)


.c-> .s
riscv64-unknown-elf-gcc -S -march=rv32i -mabi=ilp32 -O0 -nostdlib -T ./Asm_Code/linker.ld ./Asm_Code/main.c -o ./Asm_Code/main.s

.s-> .o
riscv64-unknown-elf-as -march=rv32i_zicsr -mabi=ilp32 -o startup.o startup.s

.o-> .elf
riscv64-unknown-elf-gcc -march=rv32i_zicsr -mabi=ilp32 -nostdlib -T linker.ld startup.o -o startup.elf

.elf-> .bin
riscv64-unknown-elf-objcopy -O binary startup.elf startup.bin

.bin-> little endian hex
xxd -p -c 4 startup.bin > startup.hex

